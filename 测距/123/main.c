void conut1(void)
{
	time=TH1*256+TL1;
	TH1=0;
	TL1=0;
	
	               //此时time的时间单位决定于晶振的频率，外接晶振为11.0592MHZ
			       //那么1us声波能走多远的距离呢？1s=1000ms=1000000us 
				   // 340/1000000=0.00034米
				   //0.00034米/1000=0.34毫米  也就是1us能走0.34毫米
				   //但是，我们现在计算的是从超声波发射到反射接收的双路程，
				   //所以我们将计算的结果除以2才是实际的路程
    S=time*0.17+10;//此时计算到的结果为毫米，并且是精确到毫米的后两位了，有两个小数点 
}

void Conut(void)
{
	 
    conut1();
	//========显示部分===========================================
	if((S>=5000)||flag==1) //超出测量范围
	{
	    a=0;	
	    flag=0;
        DisplayListChar(0, 1, table1);
	}
	else
	{
        disbuff[0]=S%10;
	    disbuff[1]=S/10%10;
	    disbuff[2]=S/100%10;
	    disbuff[3]=S/1000;
	    DisplayListChar(0, 1, table);
	    DisplayOneChar(9, 1, ASCII[disbuff[3]]);
	    DisplayOneChar(10, 1, ASCII[disbuff[2]]);	
	    DisplayOneChar(11, 1, ASCII[disbuff[1]]);
        DisplayOneChar(12, 1, ASCII[10]);
	    DisplayOneChar(13, 1, ASCII[disbuff[0]]);
	 }
	 //========避障部分===========================================
	 if(S<=240)	 ////////////////////////////  刹车障碍物距离	跟车速有关 可更改
	 {	
	      a++;
	      if(a>=2)
	      {
	          a=0;
	          FM=0;
		      Stop();
		      back();  //后退缓冲
		      delay(230);//////////////////////////////////////////	后退缓冲时间 跟车速有关 可更改

	          B:Turn_Right();
		        delay(50);		  ///////////////////////////////////  旋转角度 跟环境复杂程度有关 可更改
		        Stop();
		        delay(100);		////////////////////////////////////   旋转顿挫时间 视觉效果 可更改
		        StartModule(); 				
		        while(RX==0);
		        TR1=1;			    //开启计数
	            while(RX);			//当RX为1计数并等待
	            TR1=0;				//关闭计数
		        conut1();


		        if(S>340)	 ////////////////////////	 可直行方向无障碍物距离 跟环境有关 可更改
		        {
	
		            Turn_Right();
		            delay(90);	
	                Stop();				  //微调前进方向 避免车宽对前进影响
		            delay(200);		   
		            FM=1;
		            Forward();
		        }		
		        else
		       {
		           goto B;				//若没转到空旷方向 回到B点 继续旋转一次
		       }
		
	       }
	       else
		   {
	           Forward();	//无障碍物 直行
	       }
	
	 }

	 else
	 {
	      a=0;
	 	  Forward();	   //无障碍物 直行
	 }
	 //=======================================
	 
}

/********************************************************/
void zd0() interrupt 3 		 //T0中断用来计数器溢出,超过测距范围
{
    flag=1;			 //中断溢出标志
	RX=0;
}

/********超声波高电平脉冲宽度计算程序***************/
void Timer_Count(void)
{
	TR1=1;			    //开启计数
	while(RX);			//当RX为1计数并等待
	TR1=0;				//关闭计数
    Conut();			//计算

}
/********************************************************/
void keyscan(void)              //按键扫描函数
{
    A:    if(K4==0)			//判断是否有按下信号
		{
		    delay(10);		  //延时10ms
			if(K4==0)			//再次判断是否按下
			 {
			    FM=0;               //蜂鸣器响  		
			    while(K4==0);	//判断是否松开按键
			    FM=1;               //蜂鸣器停止  
		 	 }
		    else
		     {
		       goto A;        //跳转到A重新检测
	              }
		}
		else
		{
		  goto A;             //跳转到A重新检测
		}
} 
/********************************************************/ 

/*************主程序********************/
void main(void)
{
    
	unsigned int a;
	cmg88();//关数码管
	delay(400); //启动等待，等LCM讲入工作状态
	LCMInit(); //LCM初始化
	delay(5);//延时片刻

	DisplayListChar(0, 0, Range);
	DisplayListChar(0, 1, table);
    TMOD=TMOD|0x10;//设T0为方式1，GATE=1；
    EA=1;					   //开启总中断
    TH1=0;
    TL1=0;          
    ET1=1;             //允许T0中断
    keyscan() ;  //按键扫描


	//=======================================================================================================================			
 	while(1)
	{
		RX=1;
	    StartModule();				 //启动模块
        for(a=951;a>0;a--)
	    {
		   
	       if(RX==1)
		   {
              Timer_Count();		 //超声波高电平脉冲宽度计算函数
		   }
    	 }
   	}
} 