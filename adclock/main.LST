C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include<reg52.h>
   2          #include"DS18B20.H"
   3          #include <string.h>
   4          #include <intrins.h>
   5          #define uint unsigned int
   6          #define uchar unsigned char
   7          #define wd 1                            //定义是否有温度功能  =0时无温度，=1时有温度
   8          
   9          
  10          #define yh 0x80 //LCD第一行的初始位置,因为LCD1602字符地址首位D7恒定为1（100000000=80）
  11          #define er 0x80+0x40 //LCD第二行初始位置（因为第二行第一个字符位置地址是0x40）
  12          
  13          //液晶屏的与C51之间的引脚连接定义（显示数据线接C51的P0口）
  14          sbit en=P2^7;
  15          sbit rw=P2^5;   //如果硬件上rw接地，就不用写这句和后面的rw=0了
  16          sbit rs=P2^6;
  17          
  18          
  19          //校时按键与C51的引脚连接定义
  20          
  21          sbit set=P3^0;          //设置键
  22          sbit add=P3^1;          //加键
  23          sbit dec=P3^2;          //减键
  24          sbit seeNL_NZ=P3^3;     //查看农历/闹钟
  25          
  26          sbit buzzer=P3^5;       //蜂鸣器，通过三极管8550驱动，端口低电平响
  27          
  28          sbit led=P0^7;          //LCD背光开关
  29          bit  led1=1;
  30          
  31          unsigned char temp_miao;
  32          unsigned char bltime;  //背光亮的时间
  33          uchar tflag;//温度正负标志
  34          
  35          //DS1302时钟芯片与C51之间的引脚连接定义
  36          sbit IO=P3^4;
  37          sbit SCLK=P3^6;
  38          sbit RST=P3^5;
  39          
  40          
  41          uchar a,miao,shi,fen,ri,yue,nian,week,setn,temp;
  42          uint flag;
  43          //flag用于读取头文件中的温度值，和显示温度值
  44          bit c_moon;
  45          
  46          uchar nz_shi=12,nz_fen=0,nz_miao=0,setNZn;      //定义闹钟变量
  47          uchar shangyimiao,bsn,temp_hour;                        //记录上一秒时间
  48          uchar T_NL_NZ;                                                  //计数器
  49          bit timerOn=0;                                                  //闹钟启用标志位
  50          bit baoshi=0;                                                   //整点报时标志位
  51          bit  p_r=0;                                                             //平年/润年  =0表示平年，=1表示润年
  52          data uchar year_moon,month_moon,day_moon,week;
  53          
  54          
  55          
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 2   

  56          sbit ACC0=ACC^0;
  57          sbit ACC7=ACC^7;
  58          /************************************************************
  59          ACC累加器=A
  60          ACC.0=E0H 
  61          
  62          ACC.0就是ACC的第0位。Acc可以位寻址。
  63          
  64          累加器ACC是一个8位的存储单元，是用来放数据的。但是，这个存储单元有其特殊的地位，
  65          是单片机中一个非常关键的单元，很多运算都要通过ACC来进行。以后在学习指令时，
  66          常用A来表示累加器。但有一些地方例外，比如在PUSH指令中，就必须用ACC这样的名字。
  67          一般的说法，A代表了累加器中的内容、而ACC代表的是累加器的地址。 
  68          ***************************************************************/
  69          
  70          
  71          
  72          //********阳历转换阴历表************************************
  73          code uchar year_code[597]={
  74                              0x04,0xAe,0x53,    //1901 0
  75                              0x0A,0x57,0x48,    //1902 3
  76                              0x55,0x26,0xBd,    //1903 6
  77                              0x0d,0x26,0x50,    //1904 9
  78                              0x0d,0x95,0x44,    //1905 12
  79                              0x46,0xAA,0xB9,    //1906 15
  80                              0x05,0x6A,0x4d,    //1907 18
  81                              0x09,0xAd,0x42,    //1908 21
  82                              0x24,0xAe,0xB6,    //1909
  83                              0x04,0xAe,0x4A,    //1910
  84                              0x6A,0x4d,0xBe,    //1911
  85                              0x0A,0x4d,0x52,    //1912
  86                              0x0d,0x25,0x46,    //1913
  87                              0x5d,0x52,0xBA,    //1914
  88                              0x0B,0x54,0x4e,    //1915
  89                              0x0d,0x6A,0x43,    //1916
  90                              0x29,0x6d,0x37,    //1917
  91                              0x09,0x5B,0x4B,    //1918
  92                              0x74,0x9B,0xC1,    //1919
  93                              0x04,0x97,0x54,    //1920
  94                              0x0A,0x4B,0x48,    //1921
  95                              0x5B,0x25,0xBC,    //1922
  96                              0x06,0xA5,0x50,    //1923
  97                              0x06,0xd4,0x45,    //1924
  98                              0x4A,0xdA,0xB8,    //1925
  99                              0x02,0xB6,0x4d,    //1926
 100                              0x09,0x57,0x42,    //1927
 101                              0x24,0x97,0xB7,    //1928
 102                              0x04,0x97,0x4A,    //1929
 103                              0x66,0x4B,0x3e,    //1930
 104                              0x0d,0x4A,0x51,    //1931
 105                              0x0e,0xA5,0x46,    //1932
 106                              0x56,0xd4,0xBA,    //1933
 107                              0x05,0xAd,0x4e,    //1934
 108                              0x02,0xB6,0x44,    //1935
 109                              0x39,0x37,0x38,    //1936
 110                              0x09,0x2e,0x4B,    //1937
 111                              0x7C,0x96,0xBf,    //1938
 112                              0x0C,0x95,0x53,    //1939
 113                              0x0d,0x4A,0x48,    //1940
 114                              0x6d,0xA5,0x3B,    //1941
 115                              0x0B,0x55,0x4f,    //1942
 116                              0x05,0x6A,0x45,    //1943
 117                              0x4A,0xAd,0xB9,    //1944
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 3   

 118                              0x02,0x5d,0x4d,    //1945
 119                              0x09,0x2d,0x42,    //1946
 120                              0x2C,0x95,0xB6,    //1947
 121                              0x0A,0x95,0x4A,    //1948
 122                              0x7B,0x4A,0xBd,    //1949
 123                              0x06,0xCA,0x51,    //1950
 124                              0x0B,0x55,0x46,    //1951
 125                              0x55,0x5A,0xBB,    //1952
 126                              0x04,0xdA,0x4e,    //1953
 127                              0x0A,0x5B,0x43,    //1954
 128                              0x35,0x2B,0xB8,    //1955
 129                              0x05,0x2B,0x4C,    //1956
 130                              0x8A,0x95,0x3f,    //1957
 131                              0x0e,0x95,0x52,    //1958
 132                              0x06,0xAA,0x48,    //1959
 133                              0x7A,0xd5,0x3C,    //1960
 134                              0x0A,0xB5,0x4f,    //1961
 135                              0x04,0xB6,0x45,    //1962
 136                              0x4A,0x57,0x39,    //1963
 137                              0x0A,0x57,0x4d,    //1964
 138                              0x05,0x26,0x42,    //1965
 139                              0x3e,0x93,0x35,    //1966
 140                              0x0d,0x95,0x49,    //1967
 141                              0x75,0xAA,0xBe,    //1968
 142                              0x05,0x6A,0x51,    //1969
 143                              0x09,0x6d,0x46,    //1970
 144                              0x54,0xAe,0xBB,    //1971
 145                              0x04,0xAd,0x4f,    //1972
 146                              0x0A,0x4d,0x43,    //1973
 147                              0x4d,0x26,0xB7,    //1974
 148                              0x0d,0x25,0x4B,    //1975
 149                              0x8d,0x52,0xBf,    //1976
 150                              0x0B,0x54,0x52,    //1977
 151                              0x0B,0x6A,0x47,    //1978
 152                              0x69,0x6d,0x3C,    //1979
 153                              0x09,0x5B,0x50,    //1980
 154                              0x04,0x9B,0x45,    //1981
 155                              0x4A,0x4B,0xB9,    //1982
 156                              0x0A,0x4B,0x4d,    //1983
 157                              0xAB,0x25,0xC2,    //1984
 158                              0x06,0xA5,0x54,    //1985
 159                              0x06,0xd4,0x49,    //1986
 160                              0x6A,0xdA,0x3d,    //1987
 161                              0x0A,0xB6,0x51,    //1988
 162                              0x09,0x37,0x46,    //1989
 163                              0x54,0x97,0xBB,    //1990
 164                              0x04,0x97,0x4f,    //1991
 165                              0x06,0x4B,0x44,    //1992
 166                              0x36,0xA5,0x37,    //1993
 167                              0x0e,0xA5,0x4A,    //1994
 168                              0x86,0xB2,0xBf,    //1995
 169                              0x05,0xAC,0x53,    //1996
 170                              0x0A,0xB6,0x47,    //1997
 171                              0x59,0x36,0xBC,    //1998
 172                              0x09,0x2e,0x50,    //1999 294
 173                              0x0C,0x96,0x45,    //2000 297
 174                              0x4d,0x4A,0xB8,    //2001
 175                              0x0d,0x4A,0x4C,    //2002
 176                              0x0d,0xA5,0x41,    //2003
 177                              0x25,0xAA,0xB6,    //2004
 178                              0x05,0x6A,0x49,    //2005
 179                              0x7A,0xAd,0xBd,    //2006
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 4   

 180                              0x02,0x5d,0x52,    //2007
 181                              0x09,0x2d,0x47,    //2008
 182                              0x5C,0x95,0xBA,    //2009
 183                              0x0A,0x95,0x4e,    //2010
 184                              0x0B,0x4A,0x43,    //2011
 185                              0x4B,0x55,0x37,    //2012
 186                              0x0A,0xd5,0x4A,    //2013
 187                              0x95,0x5A,0xBf,    //2014
 188                              0x04,0xBA,0x53,    //2015
 189                              0x0A,0x5B,0x48,    //2016
 190                              0x65,0x2B,0xBC,    //2017
 191                              0x05,0x2B,0x50,    //2018
 192                              0x0A,0x93,0x45,    //2019
 193                              0x47,0x4A,0xB9,    //2020
 194                              0x06,0xAA,0x4C,    //2021
 195                              0x0A,0xd5,0x41,    //2022
 196                              0x24,0xdA,0xB6,    //2023
 197                              0x04,0xB6,0x4A,    //2024
 198                              0x69,0x57,0x3d,    //2025
 199                              0x0A,0x4e,0x51,    //2026
 200                              0x0d,0x26,0x46,    //2027
 201                              0x5e,0x93,0x3A,    //2028
 202                              0x0d,0x53,0x4d,    //2029
 203                              0x05,0xAA,0x43,    //2030
 204                              0x36,0xB5,0x37,    //2031
 205                              0x09,0x6d,0x4B,    //2032
 206                              0xB4,0xAe,0xBf,    //2033
 207                              0x04,0xAd,0x53,    //2034
 208                              0x0A,0x4d,0x48,    //2035
 209                              0x6d,0x25,0xBC,    //2036
 210                              0x0d,0x25,0x4f,    //2037
 211                              0x0d,0x52,0x44,    //2038
 212                              0x5d,0xAA,0x38,    //2039
 213                              0x0B,0x5A,0x4C,    //2040
 214                              0x05,0x6d,0x41,    //2041
 215                              0x24,0xAd,0xB6,    //2042
 216                              0x04,0x9B,0x4A,    //2043
 217                              0x7A,0x4B,0xBe,    //2044
 218                              0x0A,0x4B,0x51,    //2045
 219                              0x0A,0xA5,0x46,    //2046
 220                              0x5B,0x52,0xBA,    //2047
 221                              0x06,0xd2,0x4e,    //2048
 222                              0x0A,0xdA,0x42,    //2049
 223                              0x35,0x5B,0x37,    //2050
 224                              0x09,0x37,0x4B,    //2051
 225                              0x84,0x97,0xC1,    //2052
 226                              0x04,0x97,0x53,    //2053
 227                              0x06,0x4B,0x48,    //2054
 228                              0x66,0xA5,0x3C,    //2055
 229                              0x0e,0xA5,0x4f,    //2056
 230                              0x06,0xB2,0x44,    //2057
 231                              0x4A,0xB6,0x38,    //2058
 232                              0x0A,0xAe,0x4C,    //2059
 233                              0x09,0x2e,0x42,    //2060
 234                              0x3C,0x97,0x35,    //2061
 235                              0x0C,0x96,0x49,    //2062
 236                              0x7d,0x4A,0xBd,    //2063
 237                              0x0d,0x4A,0x51,    //2064
 238                              0x0d,0xA5,0x45,    //2065
 239                              0x55,0xAA,0xBA,    //2066
 240                              0x05,0x6A,0x4e,    //2067
 241                              0x0A,0x6d,0x43,    //2068
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 5   

 242                              0x45,0x2e,0xB7,    //2069
 243                              0x05,0x2d,0x4B,    //2070
 244                              0x8A,0x95,0xBf,    //2071
 245                              0x0A,0x95,0x53,    //2072
 246                              0x0B,0x4A,0x47,    //2073
 247                              0x6B,0x55,0x3B,    //2074
 248                              0x0A,0xd5,0x4f,    //2075
 249                              0x05,0x5A,0x45,    //2076
 250                              0x4A,0x5d,0x38,    //2077
 251                              0x0A,0x5B,0x4C,    //2078
 252                              0x05,0x2B,0x42,    //2079
 253                              0x3A,0x93,0xB6,    //2080
 254                              0x06,0x93,0x49,    //2081
 255                              0x77,0x29,0xBd,    //2082
 256                              0x06,0xAA,0x51,    //2083
 257                              0x0A,0xd5,0x46,    //2084
 258                              0x54,0xdA,0xBA,    //2085
 259                              0x04,0xB6,0x4e,    //2086
 260                              0x0A,0x57,0x43,    //2087
 261                              0x45,0x27,0x38,    //2088
 262                              0x0d,0x26,0x4A,    //2089
 263                              0x8e,0x93,0x3e,    //2090
 264                              0x0d,0x52,0x52,    //2091
 265                              0x0d,0xAA,0x47,    //2092
 266                              0x66,0xB5,0x3B,    //2093
 267                              0x05,0x6d,0x4f,    //2094
 268                              0x04,0xAe,0x45,    //2095
 269                              0x4A,0x4e,0xB9,    //2096
 270                              0x0A,0x4d,0x4C,    //2097
 271                              0x0d,0x15,0x41,    //2098
 272                              0x2d,0x92,0xB5,    //2099
 273          };
 274          
 275          ///月份数据表
 276          code uchar day_code1[9]={0x0,0x1f,0x3b,0x5a,0x78,0x97,0xb5,0xd4,0xf3};
 277          code uint day_code2[3]={0x111,0x130,0x14e};
 278          
 279          /*
 280          函数功能:输入BCD阳历数据,输出BCD阴历数据(只允许1901-2099年)
 281          调用函数示例:Conversion(c_sun,year_sun,month_sun,day_sun)
 282          如:计算2004年10月16日Conversion(0,0x4,0x10,0x16);
 283          c_sun,year_sun,month_sun,day_sun均为BCD数据,c_sun为世纪标志位,c_sun=0为21世
 284          纪,c_sun=1为19世纪
 285          调用函数后,原有数据不变,读c_moon,year_moon,month_moon,day_moon得出阴历BCD数据
 286          */
 287          
 288          bit c_moon;
 289          data uchar year_moon,month_moon,day_moon,week;
 290          //子函数,用于读取数据表中农历月的大月或小月,如果该月为大返回1,为小返回0
 291          bit get_moon_day(uchar month_p,uint table_addr)
 292          {
 293   1              uchar temp;
 294   1          switch (month_p){
 295   2              case 1:{temp=year_code[table_addr]&0x08;
 296   3                   if (temp==0)return(0);else return(1);}
 297   2              case 2:{temp=year_code[table_addr]&0x04;
 298   3                   if (temp==0)return(0);else return(1);}
 299   2              case 3:{temp=year_code[table_addr]&0x02;
 300   3                   if (temp==0)return(0);else return(1);}
 301   2              case 4:{temp=year_code[table_addr]&0x01;
 302   3                   if (temp==0)return(0);else return(1);}
 303   2              case 5:{temp=year_code[table_addr+1]&0x80;
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 6   

 304   3                   if (temp==0) return(0);else return(1);}
 305   2              case 6:{temp=year_code[table_addr+1]&0x40;
 306   3                   if (temp==0)return(0);else return(1);}
 307   2              case 7:{temp=year_code[table_addr+1]&0x20;
 308   3                   if (temp==0)return(0);else return(1);}
 309   2              case 8:{temp=year_code[table_addr+1]&0x10;
 310   3                   if (temp==0)return(0);else return(1);}
 311   2              case 9:{temp=year_code[table_addr+1]&0x08;
 312   3                   if (temp==0)return(0);else return(1);}
 313   2              case 10:{temp=year_code[table_addr+1]&0x04;
 314   3                   if (temp==0)return(0);else return(1);}
 315   2              case 11:{temp=year_code[table_addr+1]&0x02;
 316   3                   if (temp==0)return(0);else return(1);}
 317   2              case 12:{temp=year_code[table_addr+1]&0x01;
 318   3                   if (temp==0)return(0);else return(1);}
 319   2              case 13:{temp=year_code[table_addr+2]&0x80;
 320   3                   if (temp==0)return(0);else return(1);}
 321   2          }
 322   1               return 0;
 323   1      }
 324          
 325          /*
 326          函数功能:输入BCD阳历数据,输出BCD阴历数据(只允许1901-2099年)
 327          调用函数示例:Conversion(c_sun,year_sun,month_sun,day_sun)
 328          如:计算2004年10月16日Conversion(0,0x4,0x10,0x16);
 329          c_sun,year_sun,month_sun,day_sun均为BCD数据,c_sun为世纪标志位,c_sun=0为21世
 330          纪,c_sun=1为19世纪
 331          调用函数后,原有数据不变,读c_moon,year_moon,month_moon,day_moon得出阴历BCD数据
 332          */
 333          
 334          void Conversion(bit c,uchar year,uchar month,uchar day)
 335          {                         //c=0 为21世纪,c=1 为19世纪 输入输出数据均为BCD数据
 336   1          uchar temp1,temp2,temp3,month_p;
 337   1          uint temp4,table_addr;
 338   1          bit flag2,flag_y;
 339   1          temp1=year/16;   //BCD->hex 先把数据转换为十六进制
 340   1          temp2=year%16;
 341   1         // year=temp1*10+temp2;
 342   1              year=temp1*16+temp2;
 343   1          temp1=month/16;
 344   1          temp2=month%16;
 345   1          //month=temp1*10+temp2;
 346   1              month=temp1*16+temp2;
 347   1          temp1=day/16;
 348   1          temp2=day%16;
 349   1          //day=temp1*10+temp2;
 350   1              day=temp1*16+temp2;
 351   1          //定位数据表地址
 352   1          if(c==0){                   
 353   2              table_addr=(year+0x64-1)*0x3;
 354   2          }
 355   1          else {
 356   2              table_addr=(year-1)*0x3;
 357   2          }
 358   1          //定位数据表地址完成
 359   1          //取当年春节所在的公历月份
 360   1          temp1=year_code[table_addr+2]&0x60; 
 361   1          temp1=_cror_(temp1,5);
 362   1          //取当年春节所在的公历月份完成
 363   1          //取当年春节所在的公历日
 364   1          temp2=year_code[table_addr+2]&0x1f; 
 365   1          //取当年春节所在的公历日完成
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 7   

 366   1          // 计算当年春年离当年元旦的天数,春节只会在公历1月或2月
 367   1          if(temp1==0x1){  
 368   2              temp3=temp2-1;  
 369   2          }  
 370   1          else{
 371   2              temp3=temp2+0x1f-1;        
 372   2          }
 373   1          // 计算当年春年离当年元旦的天数完成
 374   1          //计算公历日离当年元旦的天数,为了减少运算,用了两个表
 375   1          //day_code1[9],day_code2[3]
 376   1          //如果公历月在九月或前,天数会少于0xff,用表day_code1[9],
 377   1          //在九月后,天数大于0xff,用表day_code2[3]
 378   1          //如输入公历日为8月10日,则公历日离元旦天数为day_code1[8-1]+10-1
 379   1          //如输入公历日为11月10日,则公历日离元旦天数为day_code2[11-10]+10-1
 380   1          if (month<10){ 
 381   2              temp4=day_code1[month-1]+day-1;
 382   2          }
 383   1          else{
 384   2              temp4=day_code2[month-10]+day-1;
 385   2          }
 386   1          if ((month>0x2)&&(year%0x4==0)){  //如果公历月大于2月并且该年的2月为闰月,天数加1
 387   2              temp4+=1;
 388   2          }
 389   1          //计算公历日离当年元旦的天数完成
 390   1          //判断公历日在春节前还是春节后
 391   1          if (temp4>=temp3){ //公历日在春节后或就是春节当日使用下面代码进行运算
 392   2              temp4-=temp3;
 393   2              month=0x1;
 394   2              month_p=0x1;  //month_p为月份指向,公历日在春节前或就是春节当日month_p指向首月
 395   2              flag2=get_moon_day(month_p,table_addr); //检查该农历月为大小还是小月,大月返回1,小月返回0
 396   2              flag_y=0;
 397   2              if(flag2==0)temp1=0x1d; //小月29天
 398   2              else temp1=0x1e; //大小30天
 399   2              temp2=year_code[table_addr]&0xf0;
 400   2              temp2=_cror_(temp2,4);  //从数据表中取该年的闰月月份,如为0则该年无闰月
 401   2              while(temp4>=temp1){
 402   3                  temp4-=temp1;
 403   3                  month_p+=1;
 404   3                  if(month==temp2){
 405   4                  flag_y=~flag_y;
 406   4                  if(flag_y==0)month+=1;
 407   4                  }
 408   3                  else month+=1;
 409   3                  flag2=get_moon_day(month_p,table_addr);
 410   3                  if(flag2==0)temp1=0x1d;
 411   3                  else temp1=0x1e;
 412   3              }
 413   2              day=temp4+1;
 414   2          }
 415   1          else{  //公历日在春节前使用下面代码进行运算
 416   2              temp3-=temp4;
 417   2              if (year==0x0){year=0x63;c=1;}
 418   2              else year-=1;
 419   2              table_addr-=0x3;
 420   2              month=0xc;
 421   2              temp2=year_code[table_addr]&0xf0;
 422   2              temp2=_cror_(temp2,4);
 423   2              if (temp2==0)
 424   2                              month_p=0xc; 
 425   2              else
 426   2                              month_p=0xd; //
 427   2              
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 8   

 428   2               //month_p为月份指向,如果当年有闰月,一年有十三个月,月指向13,无闰月指向12
 429   2              
 430   2              flag_y=0;
 431   2              flag2=get_moon_day(month_p,table_addr);
 432   2              if(flag2==0)temp1=0x1d;
 433   2              else temp1=0x1e;
 434   2              while(temp3>temp1){
 435   3                  temp3-=temp1;
 436   3                  month_p-=1;
 437   3                  if(flag_y==0)month-=1;
 438   3                  if(month==temp2)flag_y=~flag_y;
 439   3                  flag2=get_moon_day(month_p,table_addr);
 440   3                  if(flag2==0)temp1=0x1d;
 441   3                  else temp1=0x1e;
 442   3               }
 443   2              day=temp1-temp3+1;
 444   2          }
 445   1          c_moon=c;                 //HEX->BCD ,运算结束后,把数据转换为BCD数据
 446   1          temp1=year/10;
 447   1          temp1=_crol_(temp1,4);
 448   1          temp2=year%10;
 449   1          year_moon=temp1|temp2;
 450   1          temp1=month/10;
 451   1          temp1=_crol_(temp1,4);
 452   1          temp2=month%10;
 453   1          month_moon=temp1|temp2;
 454   1          temp1=day/10;
 455   1          temp1=_crol_(temp1,4);
 456   1          temp2=day%10;
 457   1          day_moon=temp1|temp2;
 458   1      }
 459          
 460          
 461          /*
 462          函数功能:输入BCD阳历数据,输出BCD星期数据(只允许1901-2099年)
 463          调用函数示例:Conver_week(c_sun,year_sun,month_sun,day_sun)
 464          如:计算2004年10月16日Conversion(0,0x4,0x10,0x16);
 465          c_sun,year_sun,month_sun,day_sun均为BCD数据,c_sun为世纪标志位,c_sun=0为21世
 466          纪,c_sun=1为19世纪
 467          调用函数后,原有数据不变,读week得出阴历BCD数据
 468          */
 469          code uchar table_week[12]={0,3,3,6,1,4,6,2,5,0,3,5}; //月修正数据表
 470          /*
 471          算法:日期+年份+所过闰年数+月较正数之和除7 的余数就是星期但如果是在
 472          闰年又不到3 月份上述之和要减一天再除7
 473          星期数为0
 474          */
 475          void Conver_week(uchar year,uchar month,uchar day)
 476          {//c=0 为21世纪,c=1 为19世纪 输入输出数据均为BCD数据
 477   1          uchar p1,p2;
 478   1          year+=0x64;  //如果为21世纪,年份数加100
 479   1          p1=year/0x4;  //所过闰年数只算1900年之后的
 480   1          p2=year+p1;
 481   1          p2=p2%0x7;  //为节省资源,先进行一次取余,避免数大于0xff,避免使用整型数据
 482   1          p2=p2+day+table_week[month-1];
 483   1          if (year%0x4==0&&month<3)p2-=1;
 484   1          week=p2%0x7;
 485   1      }
 486          
 487          
 488          /**************************************************************/
 489          
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 9   

 490          uchar code tab1[]={"20  -  -   "};      //年显示的固定字符
 491          uchar code tab2[]={"  :  :  "};         //时间显示的固定字符
 492          uchar code nlp[]={"NL:  -  -   PING"};  //农历平年显示
 493          uchar code nlr[]={"NL:  -  -   RUN "};  //农历润年显示
 494          uchar code NZd[]={"timer:    -  -  "};  //显示闹钟固定点
 495          uchar code qk[]= {"                "};  //清空显示
 496          uchar code tm[]= {"time"};
 497          
 498          
 499          //延时函数，后面经常调用
 500          void delay(uint xms)//延时函数，有参函数
 501          {
 502   1              uint x,y;
 503   1              for(x=xms;x>0;x--)
 504   1               for(y=110;y>0;y--);
 505   1      }
 506          
 507          /********液晶写入指令函数与写入数据函数，以后可调用**************/
 508          
 509          /*在这个程序中，液晶写入有关函数会在DS1302的函数中调用，所以液晶程序要放在前面*/
 510          
 511          void write_1602com(uchar com)//****液晶写入指令函数****
 512          {
 513   1              rs=0;//数据/指令选择置为指令
 514   1              rw=0; //读写选择置为写
 515   1              P0=com;//送入数据
 516   1              delay(1);
 517   1              en=1;//拉高使能端，为制造有效的下降沿做准备
 518   1              delay(1);
 519   1              en=0;//en由高变低，产生下降沿，液晶执行命令
 520   1      }
 521          
 522          
 523          void write_1602dat(uchar dat)//***液晶写入数据函数****
 524          {
 525   1              rs=1;//数据/指令选择置为数据
 526   1              rw=0; //读写选择置为写
 527   1              P0=dat;//送入数据
 528   1              delay(1);
 529   1              en=1; //en置高电平，为制造下降沿做准备
 530   1              delay(1);
 531   1              en=0; //en由高变低，产生下降沿，液晶执行命令
 532   1      }
 533          
 534          
 535          void lcd_init(void)//***液晶初始化函数****
 536          {
 537   1              write_1602com(0x38);//设置液晶工作模式，意思：16*2行显示，5*7点阵，8位数据
 538   1              write_1602com(0x0c);//开显示不显示光标
 539   1              write_1602com(0x06);//整屏不移动，光标自动右移
 540   1              write_1602com(0x01);//清显示
 541   1      
 542   1              write_1602com(yh+1);//日历显示固定符号从第一行第1个位置之后开始显示
 543   1              for(a=0;a<14;a++)
 544   1              {
 545   2              write_1602dat(tab1[a]);//向液晶屏写日历显示的固定符号部分
 546   2              //delay(3);
 547   2              }
 548   1              write_1602com(er);//时间显示固定符号写入位置，从第2个位置后开始显示
 549   1              for(a=0;a<8;a++)
 550   1              {
 551   2              write_1602dat(tab2[a]);//写显示时间固定符号，两个冒号
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 10  

 552   2              //delay(3);
 553   2              }
 554   1      
 555   1      }
 556          
 557          /*********************over***********************/
 558          
 559          
 560          /***************DS1302有关子函数********************/
 561          void write_byte(uchar dat)//写一个字节
 562          {
 563   1              ACC=dat;
 564   1              RST=1;
 565   1              for(a=8;a>0;a--)
 566   1              {
 567   2                      IO=ACC0;
 568   2                      SCLK=0;
 569   2                      SCLK=1;
 570   2                      ACC=ACC>>1;
 571   2              }
 572   1      }
 573          uchar read_byte()//读一个字节
 574          {
 575   1              RST=1;
 576   1              for(a=8;a>0;a--)
 577   1              {
 578   2                      ACC7=IO;
 579   2                      SCLK=1;
 580   2                      SCLK=0;
 581   2                      ACC=ACC>>1;
 582   2      
 583   2              }
 584   1              return (ACC);
 585   1      }
 586          //----------------------------------------
 587          void write_1302(uchar add,uchar dat)//向1302芯片写函数，指定写入地址，数据
 588          {
 589   1              RST=0;
 590   1              SCLK=0;
 591   1              RST=1;
 592   1              write_byte(add);
 593   1              write_byte(dat);
 594   1              SCLK=1;
 595   1              RST=0;
 596   1      }
 597          uchar read_1302(uchar add)//从1302读数据函数，指定读取数据来源地址
 598          {
 599   1              uchar temp;
 600   1              RST=0;
 601   1              SCLK=0;
 602   1              RST=1;
 603   1              write_byte(add);
 604   1              temp=read_byte();
 605   1              SCLK=1;
 606   1              RST=0;
 607   1              return(temp);
 608   1      }
 609          
 610          uchar BCD_Decimal(uchar bcd)//BCD码转十进制函数，输入BCD，返回十进制
 611          {
 612   1               uchar Decimal;
 613   1               Decimal=bcd>>4;
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 11  

 614   1               return(Decimal=Decimal*10+(bcd&=0x0F));
 615   1      }
 616          
 617          //--------------------------------------
 618          void ds1302_init() //1302芯片初始化子函数(2010-01-07,12:00:00,week4)
 619          {
 620   1              RST=0;
 621   1              SCLK=0;
 622   1              
 623   1              write_1302(0x8e,0x00); //允许写，禁止写保护 
 624   1              //write_1302(0x80,0x00); //向DS1302内写秒寄存器80H写入初始秒数据00
 625   1              //write_1302(0x82,0x00);//向DS1302内写分寄存器82H写入初始分数据00
 626   1              //write_1302(0x84,0x12);//向DS1302内写小时寄存器84H写入初始小时数据12
 627   1              //write_1302(0x8a,0x04);//向DS1302内写周寄存器8aH写入初始周数据4
 628   1              //write_1302(0x86,0x07);//向DS1302内写日期寄存器86H写入初始日期数据07
 629   1              //write_1302(0x88,0x01);//向DS1302内写月份寄存器88H写入初始月份数据01
 630   1              //write_1302(0x8c,0x10);//向DS1302内写年份寄存器8cH写入初始年份数据10
 631   1              write_1302(0x8e,0x80); //打开写保护
 632   1      }
 633          
 634          
 635          //------------------------------------
 636          //温度显示子函数
 637          void write_temp(uchar add,uint dat)//向LCD写温度数据,并指定显示位置
 638          {
 639   1              uchar gw,sw,bw,qw;
 640   1              //bw=dat/100;//取得百位
 641   1              //sw=dat%100/10;//取得十位数字
 642   1              //gw=dat%10;//取得个位数字
 643   1         
 644   1         qw=dat/1000;//百位数
 645   1         bw=dat%1000/100;//十位数
 646   1         sw=dat%100/10;//个位数
 647   1         gw=dat%10;//小数位
 648   1         if(tflag==1)
 649   1         {
 650   2            write_1602com(er+add);//er是头文件规定的值0x80+0x40
 651   2            write_1602dat(0x2d);  //负号标志
 652   2            write_1602dat(0x30+bw);
 653   2            write_1602dat(0x30+sw);//数字+30得到该数字的LCD1602显示码
 654   2            write_1602dat('.');
 655   2            write_1602dat(0x30+gw);//数字+30得到该数字的LCD1602显示码
 656   2            write_1602dat(0xdf);//显示温度的小圆圈符号，0xdf是液晶屏字符库的该符号地址码
 657   2            write_1602dat(0x43);      //显示"C"符号，0x43是液晶屏字符库里大写C的地址码        
 658   2         }
 659   1         else
 660   1         {
 661   2            write_1602com(er+add);//er是头文件规定的值0x80+0x40
 662   2            write_1602dat(0x30+qw);
 663   2            write_1602dat(0x30+bw);
 664   2            write_1602dat(0x30+sw);//数字+30得到该数字的LCD1602显示码
 665   2            write_1602dat('.');
 666   2            write_1602dat(0x30+gw);//数字+30得到该数字的LCD1602显示码
 667   2            write_1602dat(0xdf);//显示温度的小圆圈符号，0xdf是液晶屏字符库的该符号地址码
 668   2            write_1602dat(0x43);      //显示"C"符号，0x43是液晶屏字符库里大写C的地址码        
 669   2         }
 670   1      }
 671          
 672          //------------------------------------
 673          //时分秒显示子函数
 674          void write_sfm(uchar add,uchar dat)//向LCD写时分秒,有显示位置加、现示数据，两个参数
 675          {
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 12  

 676   1              uchar gw,sw;
 677   1              gw=dat%10;//取得个位数字
 678   1              sw=dat/10;//取得十位数字
 679   1              write_1602com(er+add);//er是头文件规定的值0x80+0x40
 680   1              write_1602dat(0x30+sw);//数字+30得到该数字的LCD1602显示码
 681   1              write_1602dat(0x30+gw);//数字+30得到该数字的LCD1602显示码                               
 682   1      }
 683          
 684          //-------------------------------------
 685          //年月日显示子函数
 686          void write_nyr(uchar add,uchar dat)//向LCD写年月日，有显示位置加数、显示数据，两个参数
 687          {
 688   1              uchar gw,sw;
 689   1              gw=dat%10;//取得个位数字
 690   1              sw=dat/10;//取得十位数字
 691   1              write_1602com(yh+add);//设定显示位置为第一个位置+add
 692   1              write_1602dat(0x30+sw);//数字+30得到该数字的LCD1602显示码
 693   1              write_1602dat(0x30+gw);//数字+30得到该数字的LCD1602显示码       
 694   1      }
 695          
 696          
 697          //------------------------------------
 698          //农历显示子函数
 699          void write_nl(uchar add,uchar dat)//向LCD写时分秒,有显示位置加、现示数据，两个参数
 700          {
 701   1              
 702   1              uchar gw,sw;
 703   1              //gw=dat%10;//取得个位数字
 704   1              //sw=dat/10;//取得十位数字
 705   1              gw=dat%16;//取得个位数字
 706   1              sw=dat/16;//取得十位数字
 707   1              write_1602com(er+add);//er是头文件规定的值0x80+0x40
 708   1      //      write_1602dat(0x30+sw);//数字+30得到该数字的LCD1602显示码
 709   1      //      write_1602dat(0x30+gw);//数字+30得到该数字的LCD1602显示码       
 710   1              write_1602dat('0'+sw);//数字+30得到该数字的LCD1602显示码
 711   1              write_1602dat('0'+gw);//数字+30得到该数字的LCD1602显示码                
 712   1      }
 713          
 714          //-------------------------------------------
 715          void write_week(uchar week)//写星期函数
 716          {
 717   1              write_1602com(yh+0x0c);//星期字符的显示位置
 718   1              switch(week)
 719   1              {
 720   2                      case 1:write_1602dat('M');//星期数为1时，显示
 721   2                                 write_1602dat('O');
 722   2                                 write_1602dat('N');
 723   2                                 break;
 724   2                 
 725   2                      case 2:write_1602dat('T');//星期数据为2时显示
 726   2                                 write_1602dat('U');
 727   2                                 write_1602dat('E');
 728   2                                 break;
 729   2                      
 730   2                      case 3:write_1602dat('W');//星期数据为3时显示
 731   2                                 write_1602dat('E');
 732   2                                 write_1602dat('D');
 733   2                                 break;
 734   2                      
 735   2                      case 4:write_1602dat('T');//星期数据为4是显示
 736   2                                 write_1602dat('H');
 737   2                                 write_1602dat('U');
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 13  

 738   2                                 break;
 739   2                      
 740   2                      case 5:write_1602dat('F');//星期数据为5时显示
 741   2                                 write_1602dat('R');
 742   2                                 write_1602dat('I');
 743   2                                 break;
 744   2                      
 745   2                      case 6:write_1602dat('S');//星期数据为6时显示
 746   2                                 write_1602dat('T');
 747   2                                 write_1602dat('A');
 748   2                                 break;
 749   2                      
 750   2                      case 0:write_1602dat('S');//星期数据为7时显示
 751   2                                 write_1602dat('U');
 752   2                                 write_1602dat('N');
 753   2                                 break;
 754   2              }
 755   1      }
 756          
 757          
 758          //****************键盘扫描有关函数**********************
 759          void keyscan()
 760          {
 761   1              if(seeNL_NZ==0)
 762   1              {
 763   2                      delay(9);
 764   2                      if(seeNL_NZ==0)
 765   2                      {
 766   3                              led1=0;
 767   3                              bltime=0;
 768   3                              if((setn==0)&&(setNZn==0))                                                              //在没有进入调时模式时才可按动
 769   3                              {
 770   4                                      buzzer=0;//蜂鸣器短响一次
 771   4                              delay(20);
 772   4                              buzzer=1;
 773   4              
 774   4                                      if(TR1==1)
 775   4                                      {
 776   5                                              TR1=0;          
 777   5                                      }
 778   4                                      else
 779   4                                      {                       
 780   5                                              T_NL_NZ++;
 781   5                                              if(T_NL_NZ==3)
 782   5                                              {
 783   6                                                      setn=0;
 784   6                                                      setNZn=0;
 785   6                                                      T_NL_NZ=0;      
 786   6                                              }
 787   5                                      }                       
 788   4                              }
 789   3                              while(seeNL_NZ==0);
 790   3                      }
 791   2              }
 792   1                              
 793   1      
 794   1              if(set==0)//---------------set为功能键（设置键）--------------------
 795   1              {
 796   2                      delay(9);//延时，用于消抖动
 797   2                      if(set==0)//延时后再次确认按键按下
 798   2                      {
 799   3                              led1=0;
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 14  

 800   3                              bltime=0;
 801   3      
 802   3                      buzzer=0;//蜂鸣器短响一次
 803   3                      delay(20);
 804   3                      buzzer=1;
 805   3                              while(!set);
 806   3                              if(T_NL_NZ==0x02)                       //证明是对闹钟进行设置
 807   3                              {
 808   4                                      setNZn++;
 809   4                                      if(setNZn==4)                   //闹钟设定成功，退回到正常显示并开启闹钟
 810   4                                      {
 811   5                                              setNZn=0;
 812   5                                              setn=0;
 813   5                                              timerOn=1;                              
 814   5                                      }
 815   4                                      switch(setNZn)
 816   4                                      {
 817   5                                              case 0:                                         //正常显示日期时间
 818   5                                                      write_1602com(0x0c);    //设置光标不闪?
 819   5                                                      write_1602com(er);              //时间显示固定符号写入位置?
 820   5                                                      for(a=0;a<16;a++)
 821   5                                                      write_1602dat(NZd[a]);  //写显示时间固定符号，两个冒号
 822   5                                                      
 823   5                                                      write_sfm(8,nz_shi);    //闹钟 时
 824   5                                                      write_sfm(11,nz_fen);   //闹钟 分
 825   5                                                      write_sfm(14,nz_miao);  //闹钟 秒
 826   5                                                      break;
 827   5                                              case 1:                                         //闹钟秒光标闪烁                
 828   5                                                      write_1602com(er+15);   //设置按键按动一次，秒位置显示光标   //er+0x09;
 829   5                                                      write_1602com(0x0f);    //设置光标为闪烁
 830   5                                                      break;
 831   5                                              case 2:                                         //闹钟分光标闪烁        
 832   5                                                      write_1602com(er+12);   //设置按键按动一次，秒位置显示光标   //er+0x09;
 833   5                                                      write_1602com(0x0f);    //设置光标为闪烁
 834   5                                                      break;
 835   5                                              case 3:                                         //闹钟时光标闪烁        
 836   5                                                      write_1602com(er+9);    //设置按键按动一次，秒位置显示光标   //er+0x09;
 837   5                                                      write_1602com(0x0f);    //设置光标为闪烁
 838   5                                                      break;  
 839   5                                      }       
 840   4                              }
 841   3      
 842   3                              else                                                            //证明是对时间及日期进行设置
 843   3                              {
 844   4                                      if(T_NL_NZ==0)
 845   4                                      {
 846   5                                              setn++;
 847   5                                              if(setn==7)
 848   5                                                      setn=0;                 //设置按键共有秒、分、时、星期、日、月、年、返回，8个功能循环
 849   5                                              switch(setn)
 850   5                                              {
 851   6                              
 852   6                                                      case 1: TR0=0;//关闭定时器
 853   6                                                      //TR1=0;
 854   6                                                      write_1602com(er+7);//设置按键按动一次，秒位置显示光标   //er+0x09;
 855   6                                                      write_1602com(0x0f);//设置光标为闪烁
 856   6                                                      temp=(miao)/10*16+(miao)%10;//秒数据写入DS1302
 857   6                                                      write_1302(0x8e,0x00);
 858   6                                                      write_1302(0x80,0x80|temp);//miao
 859   6                                                  write_1302(0x8e,0x80);
 860   6                                                      break;
 861   6                                                      case 2:  
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 15  

 862   6                                                      write_1602com(er+4);  //按2次fen位置显示光标   //er+0x06        
 863   6                                                       //write_1602com(0x0f);
 864   6                                                      break;
 865   6                                                      case 3: 
 866   6                                                      write_1602com(er+1);   //按动3次，shi
 867   6                                              //write_1602com(0x0f);
 868   6                                                      break;
 869   6                                              //      case 4: write_1602com(yh+0x0e);//按动4次，week
 870   6                                                  //write_1602com(0x0f);
 871   6                                              //      break;
 872   6                                                      case 4: write_1602com(yh+0x0a);//按动4次，ri
 873   6                                                   //write_1602com(0x0f);
 874   6                                                      break;
 875   6                                                      case 5: write_1602com(yh+0x07);//按动5次，yue
 876   6                                                   //write_1602com(0x0f);
 877   6                                                      break;
 878   6                                                      case 6: write_1602com(yh+0x04);//按动6次，nian
 879   6                                                 //write_1602com(0x0f);
 880   6                                                      break;
 881   6                                                      case 0:
 882   6                                                      write_1602com(0x0c);//按动到第7次，设置光标不闪烁
 883   6                                                      TR0=1;//打开定时器
 884   6                                              temp=(miao)/10*16+(miao)%10;
 885   6                                                      write_1302(0x8e,0x00);
 886   6                                                      write_1302(0x80,0x00|temp);//miao数据写入DS1302
 887   6                                                      write_1302(0x8e,0x80);
 888   6                                      break;  
 889   6                                              }                                                                                                       
 890   5                                      }
 891   4                              }
 892   3                      }
 893   2              }
 894   1      //------------------------------加键add----------------------------             
 895   1              if((setn!=0)&&(setNZn==0))//当set按下以下。再按以下键才有效（按键次数不等于零）
 896   1              {
 897   2                      if(add==0)  //上调键
 898   2                      {
 899   3                              delay(10);
 900   3                              if(add==0)
 901   3                              {
 902   4                                      led1=0;
 903   4                                      bltime=0;
 904   4      
 905   4                                  buzzer=0;//蜂鸣器短响一次
 906   4                                  delay(20);
 907   4                                  buzzer=1;
 908   4                                      while(!add);
 909   4                                      switch(setn)
 910   4                                      {
 911   5                                              case 1:miao++;//设置键按动1次，调秒
 912   5                                                              if(miao==60)
 913   5                                                                      miao=0;//秒超过59，再加1，就归零
 914   5                                                              write_sfm(0x06,miao);//令LCD在正确位置显示"加"设定好的秒数
 915   5                                                              temp=(miao)/10*16+(miao)%10;//十进制转换成DS1302要求的DCB码
 916   5                                                              write_1302(0x8e,0x00); //允许写，禁止写保护 
 917   5                                                              write_1302(0x80,temp); //向DS1302内写秒寄存器80H写入调整后的秒数据BCD码
 918   5                                                              write_1302(0x8e,0x80); //打开写保护
 919   5                                                              write_1602com(er+7);//因为设置液晶的模式是写入数据后，光标自动右移，所以要指定返回
 920   5                                                              //write_1602com(0x0b);
 921   5                                                              break;
 922   5                                              case 2:fen++;
 923   5                                                              if(fen==60)
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 16  

 924   5                                                                      fen=0;
 925   5                                                              write_sfm(0x03,fen);//令LCD在正确位置显示"加"设定好的分数据
 926   5                                                              temp=(fen)/10*16+(fen)%10;//十进制转换成DS1302要求的DCB码
 927   5                                                              write_1302(0x8e,0x00);//允许写，禁止写保护 
 928   5                                                              write_1302(0x82,temp);//向DS1302内写分寄存器82H写入调整后的分数据BCD码
 929   5                                                              write_1302(0x8e,0x80);//打开写保护
 930   5                                                              write_1602com(er+4);//因为设置液晶的模式是写入数据后，指针自动加一，在这里是写回原来的位置
 931   5                                                              break;
 932   5                                              case 3:shi++;
 933   5                                                              if(shi==24)
 934   5                                                                      shi=0;
 935   5                                                              write_sfm(0x00,shi);//令LCD在正确的位置显示"加"设定好的小时数据
 936   5                                                              temp=(shi)/10*16+(shi)%10;//十进制转换成DS1302要求的DCB码
 937   5                                                              write_1302(0x8e,0x00);//允许写，禁止写保护 
 938   5                                                              write_1302(0x84,temp);//向DS1302内写小时寄存器84H写入调整后的小时数据BCD码
 939   5                                                              write_1302(0x8e,0x80);//打开写保护
 940   5                                                              write_1602com(er+1);//因为设置液晶的模式是写入数据后，指针自动加一，所以需要光标回位
 941   5                                                              break;
 942   5                                              /*
 943   5                                              case 4:week++;
 944   5                                                              if(week==8)
 945   5                                                                      week=1;
 946   5                                                  write_1602com(yh+0x0C);//指定'加'后的周数据显示位置
 947   5                                                                      write_week(week);//指定周数据显示内容
 948   5                                                  temp=(week)/10*16+(week)%10;//十进制转换成DS1302要求的DCB码
 949   5                                                              write_1302(0x8e,0x00);//允许写，禁止写保护 
 950   5                                                              write_1302(0x8a,temp);//向DS1302内写周寄存器8aH写入调整后的周数据BCD码
 951   5                                                              write_1302(0x8e,0x80);//打开写保护
 952   5                                                                 write_1602com(yh+0x0e);//因为设置液晶的模式是写入数据后，指针自动加一，所以需要光标回位
 953   5                                                              break;
 954   5                                              */
 955   5                                              case 4:ri++;
 956   5                                                              if((yue==12)||(yue==10)||(yue==8)||(yue==7)||(yue==5)||(yue==3)||(yue==1))
 957   5                        {
 958   6                           if(ri>=32)  ri=1;
 959   6                        }  
 960   5                        else if(yue!=2)
 961   5                        {
 962   6                           if(ri>=31)  ri=1;
 963   6                        }
 964   5                                                      else
 965   5                        {
 966   6                           if(((nian%4)==0))
 967   6                                                              {
 968   7                              if(nian%100==0)
 969   7                              {
 970   8                                 if((nian%400)==0) if(ri==30)  ri=1;
 971   8                                 else if(ri>=29)  ri=1;
 972   8                              }
 973   7                              else if(ri>29)  ri=1;
 974   7                           }
 975   6                           else if(ri>=29)  ri=1;
 976   6                        }
 977   5                                                              Conver_week(nian,yue,ri);
 978   5                                                              write_week(week);
 979   5                                                              write_nyr(9,ri);//令LCD在正确的位置显示"加"设定好的日期数据
 980   5                                                              temp=(ri)/10*16+(ri)%10;//十进制转换成DS1302要求的DCB码
 981   5                                                              write_1302(0x8e,0x00);//允许写，禁止写保护
 982   5                                                              write_1302(0x86,temp);//向DS1302内写日期寄存器86H写入调整后的日期数据BCD码
 983   5                                                              write_1302(0x8e,0x80);//打开写保护
 984   5                                                              write_1602com(yh+10);//因为设置液晶的模式是写入数据后，指针自动加一，所以需要光标回位
 985   5                                      
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 17  

 986   5                                                              break;
 987   5                                              case 5:yue++;
 988   5                                                              if(yue==13)     yue=1;
 989   5                           if((yue==11)||(yue==9)||(yue==6)||(yue==4))
 990   5                           {
 991   6                              if(ri>30)  {ri=30;write_nyr(9,ri);}//令LCD在正确的位置显示"加"设定好的日期数据
 992   6                           }  
 993   5                           else if(yue==2)
 994   5                           {
 995   6                              if(((nian%4)==0))
 996   6                              {
 997   7                                 if(nian%100==0)
 998   7                                 {
 999   8                                    if((nian%400)==0) 
1000   8                                    {
1001   9                                       if(ri>29)
1002   9                                       {ri=29;write_nyr(9,ri);}
1003   9                                    }
1004   8                                 }
1005   7                                 else if(ri>29) {ri=29;write_nyr(9,ri);}
1006   7                              }
1007   6                              else if(ri>28)  {ri=28;write_nyr(9,ri);}
1008   6                              
1009   6                           }
1010   5                                                              Conver_week(nian,yue,ri);
1011   5                                                              write_week(week);
1012   5                                                              write_nyr(6,yue);//令LCD在正确的位置显示"加"设定好的月份数据
1013   5                                                              temp=(yue)/10*16+(yue)%10;//十进制转换成DS1302要求的DCB码
1014   5                                                              write_1302(0x8e,0x00);//允许写，禁止写保护
1015   5                                                              write_1302(0x88,temp);//向DS1302内写月份寄存器88H写入调整后的月份数据BCD码
1016   5                                                              write_1302(0x8e,0x80);//打开写保护
1017   5                                                              write_1602com(yh+7);//因为设置液晶的模式是写入数据后，指针自动加一，所以需要光标回位
1018   5                                      
1019   5                                                              break;
1020   5                                              case 6:nian++;
1021   5                                                       if(nian==100)
1022   5                                                              nian=0;
1023   5                           if(yue==2)
1024   5                           {
1025   6                              if(((nian%4)==0))
1026   6                              {
1027   7                                 if(nian%100==0)
1028   7                                 {
1029   8                                    if((nian%400)==0) 
1030   8                                    {
1031   9                                       if(ri>29)
1032   9                                       {ri=29;write_nyr(9,ri);}
1033   9                                    }
1034   8                                 }
1035   7                                 else if(ri>29) {ri=29;write_nyr(9,ri);}
1036   7                              }
1037   6                              else if(ri>28)  {ri=28;write_nyr(9,ri);}
1038   6                              
1039   6                           }
1040   5                                                              Conver_week(nian,yue,ri);
1041   5                                                              write_week(week);
1042   5                                                              write_nyr(3,nian);//令LCD在正确的位置显示"加"设定好的年份数据
1043   5                                                  temp=(nian)/10*16+(nian)%10;//十进制转换成DS1302要求的DCB码
1044   5                                                              write_1302(0x8e,0x00);//允许写，禁止写保护
1045   5                                                              write_1302(0x8c,temp);//向DS1302内写年份寄存器8cH写入调整后的年份数据BCD码
1046   5                                                              write_1302(0x8e,0x80);//打开写保护
1047   5                                                              write_1602com(yh+4);//因为设置液晶的模式是写入数据后，指针自动加一，所以需要光标回位
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 18  

1048   5                                      
1049   5                                                              break;
1050   5                                      }
1051   4                              }
1052   3              
1053   3                      }
1054   2                      //------------------减键dec，各句功能参照'加键'注释---------------
1055   2                      if(dec==0)
1056   2                      {
1057   3                              delay(10);//调延时，消抖动
1058   3                              if(dec==0)
1059   3                              {
1060   4                                      led1=0;
1061   4                                      bltime=0;
1062   4      
1063   4                              buzzer=0;//蜂鸣器短响一次
1064   4                                  delay(20);
1065   4                                  buzzer=1;
1066   4                                      while(!dec);
1067   4                                      switch(setn)
1068   4                                      {
1069   5                                              case 1:
1070   5                                                      miao--;
1071   5                                                      if(miao==-1)
1072   5                                                              miao=59;//秒数据减到-1时自动变成59
1073   5                                                      write_sfm(0x06,miao);//在LCD的正确位置显示改变后新的秒数
1074   5                                          temp=(miao)/10*16+(miao)%10;//十进制转换成DS1302要求的DCB码
1075   5                                                      write_1302(0x8e,0x00); //允许写，禁止写保护 
1076   5                                                      write_1302(0x80,temp); //向DS1302内写秒寄存器80H写入调整后的秒数据BCD码
1077   5                                                      write_1302(0x8e,0x80); //打开写保护
1078   5                                                      write_1602com(er+7);//因为设置液晶的模式是写入数据后，指针自动加一，在这里是写回原来的位置
1079   5                                                      //write_1602com(0x0b);
1080   5                                                      break;
1081   5                                              case 2:
1082   5                                                      fen--;
1083   5                                                      if(fen==-1)
1084   5                                                      fen=59;
1085   5                                                      write_sfm(3,fen);
1086   5                                                      temp=(fen)/10*16+(fen)%10;//十进制转换成DS1302要求的DCB码
1087   5                                                      write_1302(0x8e,0x00);//允许写，禁止写保护 
1088   5                                                      write_1302(0x82,temp);//向DS1302内写分寄存器82H写入调整后的分数据BCD码
1089   5                                                      write_1302(0x8e,0x80);//打开写保护
1090   5                                                      write_1602com(er+4);//因为设置液晶的模式是写入数据后，指针自动加一，在这里是写回原来的位置
1091   5                                                      break;
1092   5              
1093   5                                              case 3:
1094   5                                                      shi--;
1095   5                                                      if(shi==-1)
1096   5                                                      shi=23;
1097   5                                                      write_sfm(0,shi);
1098   5                                                      temp=(shi)/10*16+(shi)%10;//十进制转换成DS1302要求的DCB码
1099   5                                                      write_1302(0x8e,0x00);//允许写，禁止写保护 
1100   5                                                      write_1302(0x84,temp);//向DS1302内写小时寄存器84H写入调整后的小时数据BCD码
1101   5                                                      write_1302(0x8e,0x80);//打开写保护
1102   5                                                      write_1602com(er+1);//因为设置液晶的模式是写入数据后，指针自动加一，所以需要光标回位
1103   5                                                      break;
1104   5                              /*
1105   5                              case 4:week--;
1106   5                                              if(week==0)
1107   5                                                      week=7;
1108   5                                       
1109   5                          write_1602com(yh+0x0C);//指定'加'后的周数据显示位置
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 19  

1110   5                                              write_week(week);//指定周数据显示内容
1111   5                                         temp=(week)/10*16+(week)%10;//十进制转换成DS1302要求的DCB码
1112   5                                      write_1302(0x8e,0x00);//允许写，禁止写保护 
1113   5                                      write_1302(0x8a,temp);//向DS1302内写周寄存器8aH写入调整后的周数据BCD码
1114   5                                      write_1302(0x8e,0x80);//打开写保护
1115   5                                         write_1602com(yh+0x0e);//因为设置液晶的模式是写入数据后，指针自动加一，所以需要光标回位
1116   5                                      break;
1117   5                              */
1118   5                                              case 4:
1119   5                                                      ri--;
1120   5                                                      if((yue==12)||(yue==10)||(yue==8)||(yue==7)||(yue==5)||(yue==3)||(yue==1))
1121   5                        {
1122   6                           if(ri==0)  ri=31;
1123   6                        }  
1124   5                        else if(yue!=2)
1125   5                        {
1126   6                           if(ri==0)  ri=30;
1127   6                        }
1128   5                                                      else
1129   5                        {
1130   6                           if(((nian%4)==0))
1131   6                                                              {
1132   7                              if(nian%100==0)
1133   7                              {
1134   8                                 if((nian%400)==0) if(ri==0)  ri=29;
1135   8                                 else if(ri==0)  ri=28;
1136   8                              }
1137   7                              else if(ri==0)  ri=29;
1138   7                           }
1139   6                           else if(ri==0)  ri=28;
1140   6                        }
1141   5                                                      Conver_week(nian,yue,ri);
1142   5                                                      write_week(week);
1143   5                                                      write_nyr(9,ri);
1144   5                                                      temp=(ri)/10*16+(ri)%10;//十进制转换成DS1302要求的DCB码
1145   5                                                      write_1302(0x8e,0x00);//允许写，禁止写保护
1146   5                                                      write_1302(0x86,temp);//向DS1302内写日期寄存器86H写入调整后的日期数据BCD码
1147   5                                                      write_1302(0x8e,0x80);//打开写保护
1148   5                                                      write_1602com(yh+10);//因为设置液晶的模式是写入数据后，指针自动加一，所以需要光标回位           
1149   5                                                      break;
1150   5                                              case 5:
1151   5                                                      yue--;
1152   5                        if(yue==0)
1153   5                                                      yue=12;
1154   5      
1155   5                        if((yue==11)||(yue==9)||(yue==6)||(yue==4))
1156   5                           {
1157   6                              if(ri>30)  {ri=30;write_nyr(9,ri);}//令LCD在正确的位置显示"加"设定好的日期数据
1158   6                           }  
1159   5                           else if(yue==2)
1160   5                           {
1161   6                              if(((nian%4)==0))
1162   6                              {
1163   7                                 if(nian%100==0)
1164   7                                 {
1165   8                                    if((nian%400)==0) 
1166   8                                    {
1167   9                                       if(ri>29)
1168   9                                       {ri=29;write_nyr(9,ri);}
1169   9                                    }
1170   8                                 }
1171   7                                 else if(ri>29) {ri=29;write_nyr(9,ri);}
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 20  

1172   7                              }
1173   6                              else if(ri>28)  {ri=28;write_nyr(9,ri);}
1174   6                              
1175   6                           }
1176   5                                                      Conver_week(nian,yue,ri);
1177   5                                                      write_week(week);
1178   5                                                      write_nyr(6,yue);
1179   5                                                      temp=(yue)/10*16+(yue)%10;//十进制转换成DS1302要求的DCB码
1180   5                                                      write_1302(0x8e,0x00);//允许写，禁止写保护
1181   5                                                      write_1302(0x88,temp);//向DS1302内写月份寄存器88H写入调整后的月份数据BCD码
1182   5                                                      write_1302(0x8e,0x80);//打开写保护
1183   5                                                      write_1602com(yh+7);//因为设置液晶的模式是写入数据后，指针自动加一，所以需要光标回位
1184   5                              
1185   5                                                      break;  
1186   5                                              case 6:
1187   5                                                      nian--;
1188   5                                                      if(nian==-1)
1189   5                                                      nian=99;
1190   5                        if(nian==100)
1191   5                                                              nian=0;
1192   5                           if(yue==2)
1193   5                           {
1194   6                              if(((nian%4)==0))
1195   6                              {
1196   7                                 if(nian%100==0)
1197   7                                 {
1198   8                                    if((nian%400)==0) 
1199   8                                    {
1200   9                                       if(ri>29)
1201   9                                       {ri=29;write_nyr(9,ri);}
1202   9                                    }
1203   8                                 }
1204   7                                 else if(ri>29) {ri=29;write_nyr(9,ri);}
1205   7                              }
1206   6                              else if(ri>28)  {ri=28;write_nyr(9,ri);}
1207   6                              
1208   6                           }
1209   5                                                      Conver_week(nian,yue,ri);
1210   5                                                      write_week(week);
1211   5                                                      write_nyr(3,nian);
1212   5                                              temp=(nian)/10*16+(nian)%10;//十进制转换成DS1302要求的DCB码
1213   5                                                      write_1302(0x8e,0x00);//允许写，禁止写保护
1214   5                                                      write_1302(0x8c,temp);//向DS1302内写年份寄存器8cH写入调整后的年份数据BCD码
1215   5                                                      write_1302(0x8e,0x80);//打开写保护
1216   5                                                      write_1602com(yh+4);//因为设置液晶的模式是写入数据后，指针自动加一，所以需要光标回位
1217   5                                                      break;
1218   5                                                                      
1219   5                                      }
1220   4                              }
1221   3                      }
1222   2              }
1223   1              if((setNZn!=0)&&(setn==0))
1224   1              {
1225   2                      if(add==0)  //上调键
1226   2                      {
1227   3                              delay(10);
1228   3                              if(add==0)
1229   3                              {
1230   4                                      led1=0;
1231   4                                      bltime=0;
1232   4      
1233   4                                  buzzer=0;//蜂鸣器短响一次
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 21  

1234   4                                  delay(20);
1235   4                                  buzzer=1;
1236   4                                      while(!add);
1237   4                                      switch(setNZn)
1238   4                                      {
1239   5                                              case 1:
1240   5                                                      nz_miao++;                              //设置键按动1次，调秒
1241   5                                                      if(nz_miao==60)
1242   5                                                              nz_miao=0;//秒超过59，再加1，就归零
1243   5                                                      write_sfm(14,nz_miao);//令LCD在正确位置显示"加"设定好的秒数
1244   5                                                      write_1602com(er+15);//因为设置液晶的模式是写入数据后，光标自动右移，所以要指定返回
1245   5                                                      break;
1246   5                                              case 2:
1247   5                                                      nz_fen++;
1248   5                                                      if(nz_fen==60)
1249   5                                                              nz_fen=0;
1250   5                                                      write_sfm(11,nz_fen);//令LCD在正确位置显示"加"设定好的分数据
1251   5                                                      write_1602com(er+12);//因为设置液晶的模式是写入数据后，指针自动加一，在这里是写回原来的位置
1252   5                                                      break;
1253   5                                              case 3:
1254   5                                                      nz_shi++;
1255   5                                                      if(nz_shi==24)
1256   5                                                              nz_shi=0;
1257   5                                                      write_sfm(8,nz_shi);//令LCD在正确的位置显示"加"设定好的小时数据
1258   5                                                      write_1602com(er+9);//因为设置液晶的模式是写入数据后，指针自动加一，所以需要光标回位
1259   5                                                      break;
1260   5                                      }
1261   4                              }
1262   3              
1263   3                      }
1264   2                      //------------------减键dec，各句功能参照'加键'注释---------------
1265   2                      if(dec==0)
1266   2                      {
1267   3                              delay(10);//调延时，消抖动
1268   3                              if(dec==0)
1269   3                              {
1270   4                                      led1=0;
1271   4                                      bltime=0;
1272   4      
1273   4                              buzzer=0;//蜂鸣器短响一次
1274   4                                  delay(20);
1275   4                                  buzzer=1;
1276   4                                      while(!dec);
1277   4                                      switch(setNZn)
1278   4                                      {
1279   5                                              case 1:
1280   5                                                      nz_miao--;
1281   5                                                      if(nz_miao==-1)
1282   5                                                              nz_miao=59;//秒数据减到-1时自动变成59
1283   5                                                      write_sfm(14,nz_miao);//在LCD的正确位置显示改变后新的秒数
1284   5                                                      write_1602com(er+15);
1285   5                                                      break;
1286   5                                              case 2:
1287   5                                                      nz_fen--;
1288   5                                                      if(nz_fen==-1)
1289   5                                                              nz_fen=59;
1290   5                                                      write_sfm(11,nz_fen);
1291   5                                                      write_1602com(er+12);//因为设置液晶的模式是写入数据后，指针自动加一，在这里是写回原来的位置
1292   5                                                      break;
1293   5              
1294   5                                              case 3:
1295   5                                                      nz_shi--;
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 22  

1296   5                                                      if(nz_shi==-1)
1297   5                                                      nz_shi=23;
1298   5                                                      write_sfm(8,nz_shi);
1299   5                                                      write_1602com(er+9);//因为设置液晶的模式是写入数据后，指针自动加一，所以需要光标回位
1300   5                                                      break;
1301   5                                                                      
1302   5                                      }
1303   4                              }
1304   3                      }
1305   2              }       
1306   1      }
1307          
1308          //-------------------------------
1309          void init(void)   //定时器、计数器设置函数
1310          {
1311   1              TMOD=0x11;              //指定定时/计数器的工作方式为3
1312   1              TH0=0;                  //定时器T0的高四位=0
1313   1              TL0=0;                  //定时器T0的低四位=0
1314   1              TH1=0x3C;
1315   1              TL1=0xB0;
1316   1              EA=1;                   //系统允许有开放的中断
1317   1              ET0=1;                  //允许T0中断
1318   1              ET1=1;
1319   1              IT1=1;
1320   1              IT0=0;
1321   1              TR0=1;                  //开启中断，启动定时器
1322   1              TR1=0;
1323   1      }
1324          
1325          
1326          void alarm(void)
1327          {
1328   1              if((shi==nz_shi)&&(fen==nz_fen)&&(miao==0))
1329   1              {
1330   2                  TR1=1;
1331   2              }
1332   1              if((shi==nz_shi)&&(fen==(nz_fen+1)))
1333   1              {
1334   2                      TR1=0;
1335   2                      buzzer=1;
1336   2              }
1337   1      }
1338          
1339          
1340          void ZD_baoshi(void)
1341          {
1342   1              buzzer=0;
1343   1              delay(5);
1344   1              buzzer=1;
1345   1              bsn++;
1346   1              if(bsn==temp_hour)
1347   1              {
1348   2                      baoshi=0;
1349   2              }
1350   1      }
1351          
1352          //*******************主函数**************************
1353          //***************************************************
1354          void main()
1355          {
1356   1              P1=0xff;
1357   1              lcd_init();      //调用液晶屏初始化子函数
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 23  

1358   1              ds1302_init();   //调用DS1302时钟的初始化子函数
1359   1              init();          //调用定时计数器的设置子函数
1360   1              led=1;           //打开LCD的背光电源
1361   1          buzzer=0;            //蜂鸣器长响一次
1362   1          delay(80);
1363   1          buzzer=1;
1364   1              while(1)  //无限循环下面的语句：
1365   1              {               
1366   2                      keyscan();      //调用键盘扫描子函数
1367   2                      led=led1;               
1368   2                      if(timerOn==1)
1369   2                              alarm();        //闹钟输出
1370   2                      if((fen==0)&&(miao==0))
1371   2                      {
1372   3                              if(shi>12)
1373   3                                      temp_hour=shi-12;
1374   3                              else
1375   3                              {
1376   4                                      if(shi==0)
1377   4                                              temp_hour=12;
1378   4                                      else
1379   4                                              temp_hour=shi;
1380   4                              }
1381   3                              shangyimiao=miao;
1382   3                              baoshi=1;
1383   3                      }
1384   2                      if(baoshi==1)
1385   2                      {
1386   3                              ZD_baoshi();
1387   3                              do 
1388   3                                      keyscan();
1389   3                              while(shangyimiao==miao);       
1390   3                              shangyimiao=miao;
1391   3                      }
1392   2          }
1393   1      }
1394          
1395          
1396          void timer0() interrupt 1  //取得并显示日历和时间
1397          {
1398   1              
1399   1         Init_DS18B20();//温度传感器DS18b2初始化子函数，在头文件中
1400   1         flag=ReadTemperature();//将18b2头文件运行返回的函数结果送到变量FLAG中，用于显示
1401   1      
1402   1        //读取秒时分周日月年七个数据（DS1302的读寄存器与写寄存器不一样）：
1403   1              
1404   1          miao = BCD_Decimal(read_1302(0x81));
1405   1              fen = BCD_Decimal(read_1302(0x83));
1406   1              shi  = BCD_Decimal(read_1302(0x85));
1407   1              ri  = BCD_Decimal(read_1302(0x87));
1408   1              yue = BCD_Decimal(read_1302(0x89));
1409   1              nian=BCD_Decimal(read_1302(0x8d));
1410   1              //week=BCD_Decimal(read_1302(0x8b));     //不读取，直接通过日期计算得到
1411   1              if((led1==0))
1412   1              {
1413   2                      if(temp_miao!=miao)
1414   2                      {
1415   3                              temp_miao=miao;
1416   3                              bltime++;
1417   3                      }
1418   2                      if(bltime==10)
1419   2                      {
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 24  

1420   3                              led1=1;
1421   3                              bltime=0;
1422   3                      }
1423   2              }
1424   1      
1425   1      
1426   1          if(T_NL_NZ==1)                                                      //显示农历
1427   1              {
1428   2                      uint nian_temp,temp;
1429   2                      temp=nian;
1430   2                      nian_temp=2000+(temp&0xF0)*10+temp&0x0F;
1431   2                      if((nian_temp%400==0)||((nian_temp%100!=0)&&(nian_temp%4==0)))  //判断是否为闰年
1432   2                              p_r=1;
1433   2                      else
1434   2                              p_r=0;
1435   2                      Conversion(0,nian,yue,ri);
1436   2                      write_1602com(er);//时间显示固定符号写入位置?
1437   2                      for(a=0;a<16;a++)
1438   2                      {
1439   3                              if(p_r==0)
1440   3                                      write_1602dat(nlp[a]);//写显示时间固定符号，两个冒号
1441   3                              else 
1442   3                                      write_1602dat(nlr[a]);
1443   3                      }
1444   2      
1445   2                      write_nl(3,year_moon);//农历 年
1446   2                      write_nl(6,month_moon);//农历 月
1447   2                      write_nl(9,day_moon);//农历 日
1448   2      
1449   2                      do
1450   2                              keyscan();
1451   2                      while(T_NL_NZ==1);
1452   2      
1453   2                      write_1602com(er);//时间显示固定符号写入位置，从第2个位置后开始显示
1454   2                      for(a=0;a<16;a++)
1455   2                      {
1456   3                              write_1602dat(qk[a]);//写显示时间固定符号，两个冒号
1457   3                      }
1458   2      
1459   2                      write_1602com(er);//时间显示固定符号写入位置，从第2个位置后开始显示
1460   2                      for(a=0;a<8;a++)
1461   2                      {
1462   3                              write_1602dat(tab2[a]);//写显示时间固定符号，两个冒号
1463   3                      }
1464   2              }
1465   1      
1466   1              if(T_NL_NZ==2)                                                          //显示闹钟时间，
1467   1              {
1468   2                      write_1602com(er);//时间显示固定符号写入位置?
1469   2                      for(a=0;a<16;a++)
1470   2                              write_1602dat(NZd[a]);//写显示时间固定符号，两个冒号
1471   2      
1472   2                      write_sfm(8,nz_shi);//农历 年
1473   2                      write_sfm(11,nz_fen);//农历 月
1474   2                      write_sfm(14,nz_miao);//农历 日
1475   2      
1476   2                      do
1477   2                              keyscan();
1478   2                      while(T_NL_NZ==2);
1479   2      
1480   2                      write_1602com(er);//时间显示固定符号写入位置，从第2个位置后开始显示
1481   2                      for(a=0;a<16;a++)
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 25  

1482   2                      {
1483   3                              write_1602dat(qk[a]);//写显示时间固定符号，两个冒号
1484   3                      }
1485   2      
1486   2                      write_1602com(er);//时间显示固定符号写入位置，从第2个位置后开始显示
1487   2                      for(a=0;a<8;a++)
1488   2                      {
1489   3                              write_1602dat(tab2[a]);//写显示时间固定符号，两个冒号
1490   3                      }
1491   2              }
1492   1              
1493   1      
1494   1              else
1495   1              {       
1496   2                      //显示温度、秒、时、分数据： 
1497   2                      if(wd)
1498   2                      { 
1499   3                              flag=ReadTemperature()-5;
1500   3                              write_temp(9,flag);//显示温度，从第二行第11个字符后开始显示
1501   3                      }
1502   2                      else
1503   2                      {
1504   3                              write_1602com(er+12);
1505   3                              for(a=0;a<4;a++)
1506   3                              {
1507   4                                      write_1602dat(tm[a]);
1508   4                              }
1509   3                      }
1510   2                      write_sfm(6,miao);//秒，从第二行第8个字后开始显示（调用时分秒显示子函数）
1511   2                      write_sfm(3,fen);//分，从第二行第5个字符后开始显示
1512   2                      write_sfm(0,shi);//小时，从第二行第2个字符后开始显示
1513   2              }       
1514   1                      //显示日、月、年数据：
1515   1                      write_nyr(9,ri);//日期，从第二行第9个字符后开始显示
1516   1                      write_nyr(6,yue);//月份，从第二行第6个字符后开始显示
1517   1                      write_nyr(3,nian);//年，从第二行第3个字符后开始显示
1518   1                      Conver_week(nian,yue,ri);
1519   1                      write_week(week);
1520   1      }
1521          
1522          
1523          unsigned char count1;
1524          
1525          void timer1() interrupt 3  //取得并显示日历和时间
1526          {
1527   1              TH1=0x3C;
1528   1              TL1=0xB0;
1529   1              TR1=1;
1530   1              count1++;
1531   1              if(count1==10)
1532   1              {
1533   2                      count1=0;
1534   2                      buzzer=!buzzer;
1535   2              }
1536   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4422    ----
   CONSTANT SIZE    =    718    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.00   MAIN                                                                  12/11/2017 12:31:16 PAGE 26  

   DATA SIZE        =     34      21
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      6       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
